<<echo=FALSE>>=
# Implementar opção para substituir o outlier por NA, média, mediana ou moda.
# Incluir o argumento probs para que o usuário possa ter flexibilidade de descartar a porcentagem que desejar.

remove_outliers <- function(x,
                             ...) UseMethod('remove_outliers') 

remove_outliers.default <- function(x,
                                     type  = 2,
                                     range = 1.5,
                                     na.rm = TRUE,
                                     ...) {

 #stop(paste("class", class(x), "objects are not valid for remove_outliersB" ))
 
 res <- x

 while(1)
 {

  q.t <- quantile(res,
                  type  = type, 
                  na.rm = na.rm)

  H <- range * (quantile(res, 
                         type  = type, 
                         na.rm = na.rm)[4] - quantile(res, 
                         type  = type, 
                         na.rm = na.rm)[2])

  ## Identificação de outliers
  out <- subset(res,
                res < q.t[2] - H |
                res > q.t[4] + H)

  ## Condição de saída
  if (length(na.omit(out)) == 0)
   return(res)

  res[res < (q.t[2] - H)] <- NA
  res[res > (q.t[4] + H)] <- NA  

 }
 class(res) <- c('remove_outliers',
                 'numeric')

 return(res) 

}

remove_outliers.matrix <- function(x,
                                    type   = 2,
                                    range  = 1.5,
                                    na.rm  = TRUE,
                                    method = c('univariate','multivariate'),
                                    ...){

 stopifnot(is.matrix(x))

 names_vars <- colnames(x)

 res <- apply(x,
              2,
              function(x) remove_outliers.default(x,
                                                  type = type,
                                                  range= range,
                                                  na.rm= na.rm))

 if(is.null(dim(res))) stop('Your data was left with only one row. Look for another alternative!')

 switch(match.arg(method),
        univariate   = {
        
         res <- res
       
        },
        
        multivariate = {

        while(any(is.na(res))) {
      
         res <- na.omit(res)

         res <- remove_outliers.matrix(res,
                                       type  = type,
                                       range = range,
                                       na.rm = na.rm,
                                       method= method)
                         }
        })

  class(res) <- c('remove_outliers.matrix',
                 'remove_outliers',
                 'matrix')  

  if(!is.null(names_vars)) colnames(res) <- names_vars

 return(res)

}

remove_outliers.data.frame <- function(x,
                                        by,
                                        type  = 2,
                                        range = 1.5,
                                        na.rm = TRUE,
                                        method= c('univariate','multivariate'),
                                        ...){

 stopifnot(is.data.frame(x)) 

 #User do not defines a factor
 if (missing(by)) {
  logCol <- sapply(x,
                   is.numeric)

  new_data <- x[,logCol]

  res <- remove_outliers.matrix(new_data,
                                 type   = type,
                                 range  = range,
                                 na.rm  = na.rm,
                                 method = method)

 }

 #User defines one factor
else {

 namesdf <- names(x)

 pos     <- which(namesdf == by)

 stopifnot(is.factor((x[[pos]])))

 numF <- table(x[[pos]])

 tmpdf <- list()
 logCol <- list()
 new_data <- list()
 res <- list()

 for (i in 1:length(numF)) {
  tmpdf[[i]]  <- subset(x,
                   x[[pos]] == names(numF[i]))

  logCol[[i]] <- sapply(tmpdf[[i]],
                   is.numeric)

  new_data[[i]] <- tmpdf[[i]][,logCol[[i]]]

  res[[i]] <- remove_outliers.matrix(as.matrix(new_data[[i]]),
                                 type   = type,
                                 range  = range,
                                 na.rm  = na.rm,
                                 method = method)
 
 }

 newnumF <- sapply(res,
                   function(x)dim(x)[1])

 groups <- rep(names(numF),
               newnumF)

 res <- data.frame(groups,
                   do.call(rbind,res),
                   row.names=NULL)

 names(res) <- c(by,
                 names(res)[-1])

}

class(res) <- c('remove_outliers.data.frame',
                'remove_outliers',
                'data.frame')   
return(res)

}

## DATA GENERATION
#options(OutDec=',')
library(truncnorm)
n <- sample(seq(7,9),
            size=1) 

mu_sinf <- ceiling(runif(1,min=20,max=50)) 
sigma_sinf <- ceiling(runif(1,min=20,max=50))  

mu_cinf <- ceiling(runif(1,min=80,max=120)) 
sigma_cinf <- ceiling(runif(1,min=30,max=40))  
 

sem_infarto <- ceiling(rtruncnorm(n,
                        a=1,
                        b=120,
                        mean=as.numeric(mu_sinf),
                        sd=as.numeric(sigma_sinf)))

com_infarto <- ceiling(rtruncnorm(n,
                                  a=21,
                                  b=180,
                                  mean=as.numeric(mu_cinf),
                                  sd=as.numeric(sigma_cinf)))

## QUESTION/ANSWER GENERATION
#questions <- solutions <- rep(list(''),7)
@

\begin{question}
  Dos arquivos de serviço de uma unidade coronariana, tomaram-se as fichas de pacientes com diagnóstico de infarto no miocardio. Estas fichas são separadas em dois grupos: em um estão aqueles que não tiveram infarto como pode ser verificado mais tarde e em outro aqueles com diagnóstico confirmado. Descartaram-se os casos duvidosos. De cada grupo foi sorteado aleatoriamente \Sexpr{2*n} casos e registrado o valor de CPK expresso em unidades enzimáticas. Os valores obtivos foram:

<<echo=F,results=tex>>=
# Dados relativo aos que não sofreram infarto
dados <- data.frame(grupos=rep(c('sinfarto','cinfarto'),c(n,n)),
                    cpk=c(sem_infarto,
                          com_infarto))
latex(dados,
      rowname=NULL,
      here=T,
      longtable=T,
      file='')
@

Para cada grupo, faça uma tabela de distribuição de frequências utilizando o método que foi ensinado em sala de aula. Utilize o critério de Sturges para encontrar o número de classes. Faça um histograma utilizando a frequência percentual. Calcule as medidas de tendência central, dispersão e posição (apenas os quartis). Faça um boxplot. Caso tenha outliers, retire-o e clacule novamente as medidas de tendência central, dispersão e posição.  

\end{question}

\begin{solution}

  A variável em estudo é uma variável quantitativa cujo a escala é de proporção ou de razão. Fazendo uma síntese do dados por meio de uma tabela de distribuição de frequências.

<<echo=F,results=tex>>=
library(fdth)
tab <- fdt(dados,
           by='grupos')
tab1 <- fdt(sem_infarto)
tab2 <- fdt(com_infarto) 

latex(tab1,
      cap='Tabela de distribuição de frequências de cpk - grupo sem infarto')
latex(tab2,
      cap='Tabela de distribuição de frequências de cpk - grupo com infarto')
@

Fazendo o histograma.
 
<<echo=F,fig=T>>=
plot(tab,
     xlab ='Intervalo de classes',
     ylab ='Frequência percentual',
     type = 'rfph' )
@

Fazendo o boxplot.

<<echo=F, fig=TRUE>>=
gr <- boxplot(cpk ~ grupos, dados)
@

Calculando todas as medidas estatísticas. 
 
<<echo=F,results=tex>>=
medi_antes_1 <- aggregate(dados[,2],
                        by=list(dados[['grupos']]),
                        function(x) c(media=mean(x),
                                      mediana=median(x),
                                      amplitude=range(x),
                                      variancia=var(x),
                                      desvio=sd(x),
                                      cv=sd(x)/mean(x),
                                      quartis=quantile(x,
                                                       type=2,
                                                       prob=c(.25,.5,.75))))
medi_antes_2 <-  t(data.frame(grupos=medi_antes_1$Group.1,
                            medidas=round(medi_antes_1$x,2)))
medi_antes <- medi_antes_2[-1,]
colnames(medi_antes) <- c('Com infarto','Sem infarto')

latex(medi_antes,
      caption='Medidas estatísticas',
      here=TRUE,
      rowlabel='Medidas',
      file='')

if(length(gr$out)!=0){

  depois <- remove_outliers(dados,
                            by='grupos')

  medi_depois_1 <- aggregate(depois[,2],
                           by=list(depois[['grupos']]),
                           function(x) c(media=mean(x,na.rm=T),
                                         mediana=median(x,na.rm=T),
                                         amplitude=range(x,na.rm=T),
                                         variancia=var(x,na.rm=T),
                                         desvio=sd(x,na.rm=T),
                                         cv=sd(x,na.rm=T)/mean(x,na.rm=T),
                                         quartis=quantile(x,
                                                          type=2,
                                                          prob=c(.25,.5,.75),
                                                          na.rm=T)))
  medi_depois_2 <-  t(data.frame(grupos=medi_depois_1$Group.1,
                                 medidas=round(medi_depois_1$x,2)))
  medi_depois <- medi_depois_2[-1,]
  colnames(medi_depois) <- c('Com infarto','Sem infarto')

  latex(medi_depois,
        caption='Medidas estatísticas depois',
        rowlabel='Medidas',
        here=TRUE,
        file='')
} 

@

\end{solution}

%% META-INFORMATION
%% \extype{string}
%% \exsolution{'Aberta'} 
%% \exname{Dados quantitativos I.} 
